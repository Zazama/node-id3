## API Report File for "node-id3"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

// @public
type Album = string;

// @public
type AlbumSortOrder = string;

// @public
type Artist = string;

// @public
type ArtistUrl = string[];

// @public
type AudioSourceUrl = string;

// @public
type Bpm = string;

// @public
type Chapter<Tags> = {
    elementID: string;
    endTimeMs: number;
    startTimeMs: number;
    startOffsetBytes?: number;
    endOffsetBytes?: number;
    tags?: Tags;
};

// @public (undocumented)
type Comment = {
    language: string;
    shortText?: string;
    text: string;
};

// @public
type CommercialFrame = {
    prices: {
        [currencyCode: string]: string | number;
    };
    validUntil: {
        year: number;
        month: number;
        day: number;
    };
    contactUrl?: string;
    receivedAs: number;
    nameOfSeller?: string;
    description?: string;
    sellerLogo?: {
        mimeType?: string;
        picture: string | Buffer;
    };
};

// @public
type CommercialUrl = string[];

// @public
type Composer = string;

// @public
type Conductor = string;

// @public
type ContentGroup = string;

// @public
type Copyright = string;

// @public
type CopyrightUrl = string;

// @public
export function create(tags: WriteTags): Buffer;

// @public
export function create(tags: WriteTags, callback: CreateCallback): void;

// @public
export type CreateCallback = (data: Buffer) => void;

// @public
type EncodedBy = string;

// @public
type EncodingTechnology = string;

// @public
type EncodingTime = string;

// @public
type EventTimingCodes = {
    timeStampFormat: Values<TagConstants['TimeStampFormat']>;
    keyEvents: {
        type: number;
        timeStamp: number;
    }[];
};

// @public
type FileOwner = string;

// @public
type FileType = string;

// @public
type FileUrl = string;

// @public
type Genre = string;

// @public
type Image = string | Buffer | {
    mime: string;
    type: {
        id: number;
        name?: string;
    };
    description?: string;
    imageBuffer: Buffer;
};

// @public
type InitialKey = string;

// @public
type InternetRadioName = string;

// @public
type InternetRadioOwner = string;

// @public
type InvolvedPeopleList = string;

// @public
type ISRC = string;

// @public
type Language = string;

// @public
type Length = string;

// @public
type MediaType = string;

// @public
type Mood = string;

// @public
type MusicianCreditsList = string;

// @public (undocumented)
export interface Options {
    exclude?: string[];
    include?: string[];
    noRaw?: boolean;
    onlyRaw?: boolean;
}

// @public
type OriginalArtist = string;

// @public
type OriginalFilename = string;

// @public
type OriginalReleaseTime = string;

// @public
type OriginalTextwriter = string;

// @public
type OriginalTitle = string;

// @public
type OriginalYear = string;

// @public
type PartOfSet = string;

// @public
type PaymentUrl = string;

// @public
type PerformerInfo = string;

// @public
type PerformerSortOrder = string;

// @public
type PlaylistDelay = string;

// @public (undocumented)
type Popularimeter = {
    email: string;
    rating: number;
    counter: number;
};

// @public (undocumented)
type Private = {
    ownerIdentifier: string;
    data: Buffer;
};

// @public
type ProducedNotice = string;

// @public
const Promises: {
    readonly create: (tags: WriteTags) => Promise<Buffer>;
    readonly write: (tags: WriteTags, filebuffer: string | Buffer) => Promise<Buffer>;
    readonly update: (tags: WriteTags, filebuffer: string | Buffer, options?: Options) => Promise<Buffer>;
    readonly read: (file: string | Buffer, options?: Options) => Promise<Tags | TagIdentifiers>;
    readonly removeTags: (filepath: string) => Promise<void>;
};
export { Promises as Promise }
export { Promises }

// @public
type Publisher = string;

// @public
type PublisherUrl = string;

// @public
type RadioStationUrl = string;

// @public
export function read(filebuffer: string | Buffer, options?: Options): Tags;

// @public
export function read(filebuffer: string | Buffer, callback: ReadCallback): void;

// @public
export function read(filebuffer: string | Buffer, options: Options, callback: ReadCallback): void;

// @public
export type ReadCallback = ReadSuccessCallback & ReadErrorCallback;

// @public
export type ReadErrorCallback = (error: NodeJS.ErrnoException | Error, tags: null) => void;

// @public
export type ReadSuccessCallback = (error: null, tags: Tags | TagIdentifiers) => void;

// @public
type RecordingDate = string;

// @public
type RecordingDates = string;

// @public
type RecordingTime = string;

// @public
type ReleaseTime = string;

// @public
type RemixArtist = string;

// @public
export type RemoveCallback = (error: NodeJS.ErrnoException | Error | null) => void;

// @public
export function removeTags(filepath: string): boolean | Error;

// @public
export function removeTags(filepath: string, callback: RemoveCallback): void;

// @public
export function removeTagsFromBuffer(data: Buffer): false | Buffer;

// @public
type SetSubtitle = string;

// @public
type Size = string;

// @public
type Subtitle = string;

// @public
interface SynchronisedLyrics {
    contentType: number;
    language: string;
    shortText?: string;
    // (undocumented)
    synchronisedText: {
        text: string;
        timeStamp: number;
    }[];
    timeStampFormat: Values<TagConstants['TimeStampFormat']>;
}

// @public (undocumented)
type TableOfContents<Tags> = {
    elementID: string;
    isOrdered?: boolean;
    elements?: string[];
    tags?: Tags;
};

// @public (undocumented)
export interface TagAliases {
    // (undocumented)
    album?: TagFrames.Album;
    // (undocumented)
    albumSortOrder?: TagFrames.AlbumSortOrder;
    // (undocumented)
    artist?: TagFrames.Artist;
    // (undocumented)
    artistUrl?: TagFrames.ArtistUrl;
    // (undocumented)
    audioSourceUrl?: TagFrames.AudioSourceUrl;
    // (undocumented)
    bpm?: TagFrames.Bpm;
    // (undocumented)
    chapter?: TagFrames.Chapter<Tags>[];
    // (undocumented)
    comment?: TagFrames.Comment;
    // (undocumented)
    commercialFrame?: TypeOrTypeArray<TagFrames.CommercialFrame>;
    // (undocumented)
    commercialUrl?: TagFrames.CommercialUrl;
    // (undocumented)
    composer?: TagFrames.Composer;
    // (undocumented)
    conductor?: TagFrames.Conductor;
    // (undocumented)
    contentGroup?: TagFrames.ContentGroup;
    // (undocumented)
    copyright?: TagFrames.Copyright;
    // (undocumented)
    copyrightUrl?: TagFrames.CopyrightUrl;
    // (undocumented)
    date?: TagFrames.RecordingDate;
    // (undocumented)
    encodedBy?: TagFrames.EncodedBy;
    // (undocumented)
    encodingTechnology?: TagFrames.EncodingTechnology;
    // (undocumented)
    encodingTime?: TagFrames.EncodingTime;
    // (undocumented)
    eventTimingCodes?: TagFrames.EventTimingCodes;
    // (undocumented)
    fileOwner?: TagFrames.FileOwner;
    // (undocumented)
    fileType?: TagFrames.FileType;
    // (undocumented)
    fileUrl?: TagFrames.FileUrl;
    // (undocumented)
    genre?: TagFrames.Genre;
    // (undocumented)
    image?: TagFrames.Image;
    // (undocumented)
    initialKey?: TagFrames.InitialKey;
    // (undocumented)
    internetRadioName?: TagFrames.InternetRadioName;
    // (undocumented)
    internetRadioOwner?: TagFrames.InternetRadioOwner;
    // (undocumented)
    involvedPeopleList?: TagFrames.InvolvedPeopleList;
    // (undocumented)
    ISRC?: TagFrames.ISRC;
    // (undocumented)
    language?: TagFrames.Language;
    // (undocumented)
    length?: TagFrames.Length;
    // (undocumented)
    mediaType?: TagFrames.MediaType;
    // (undocumented)
    mood?: TagFrames.Mood;
    // (undocumented)
    musicianCreditsList?: TagFrames.MusicianCreditsList;
    // (undocumented)
    originalArtist?: TagFrames.OriginalArtist;
    // (undocumented)
    originalFilename?: TagFrames.OriginalFilename;
    // (undocumented)
    originalReleaseTime?: TagFrames.OriginalReleaseTime;
    // (undocumented)
    originalTextwriter?: TagFrames.OriginalTextwriter;
    // (undocumented)
    originalTitle?: TagFrames.OriginalTitle;
    // (undocumented)
    originalYear?: TagFrames.OriginalYear;
    // (undocumented)
    partOfSet?: TagFrames.PartOfSet;
    // (undocumented)
    paymentUrl?: TagFrames.PaymentUrl;
    // (undocumented)
    performerInfo?: TagFrames.PerformerInfo;
    // (undocumented)
    performerSortOrder?: TagFrames.PerformerSortOrder;
    // (undocumented)
    playlistDelay?: TagFrames.PlaylistDelay;
    // (undocumented)
    popularimeter?: TagFrames.Popularimeter;
    // (undocumented)
    private?: TypeOrTypeArray<TagFrames.Private>;
    // (undocumented)
    producedNotice?: TagFrames.ProducedNotice;
    // (undocumented)
    publisher?: TagFrames.Publisher;
    // (undocumented)
    publisherUrl?: TagFrames.PublisherUrl;
    // (undocumented)
    radioStationUrl?: TagFrames.RadioStationUrl;
    // (undocumented)
    recordingDates?: TagFrames.RecordingDates;
    // (undocumented)
    recordingTime?: TagFrames.RecordingTime;
    // (undocumented)
    releaseTime?: TagFrames.ReleaseTime;
    // (undocumented)
    remixArtist?: TagFrames.RemixArtist;
    // (undocumented)
    setSubtitle?: TagFrames.SetSubtitle;
    // (undocumented)
    size?: TagFrames.Size;
    // (undocumented)
    subtitle?: TagFrames.Subtitle;
    // (undocumented)
    synchronisedLyrics?: TypeOrTypeArray<TagFrames.SynchronisedLyrics>;
    // (undocumented)
    tableOfContents?: TagFrames.TableOfContents<Tags>[];
    // (undocumented)
    taggingTime?: TagFrames.TaggingTime;
    // (undocumented)
    textWriter?: TagFrames.TextWriter;
    // (undocumented)
    time?: TagFrames.Time;
    // (undocumented)
    title?: TagFrames.Title;
    // (undocumented)
    titleSortOrder?: TagFrames.TitleSortOrder;
    // (undocumented)
    trackNumber?: TagFrames.TrackNumber;
    // (undocumented)
    uniqueFileIdentifier?: TypeOrTypeArray<TagFrames.UniqueFileIdentifier>;
    // (undocumented)
    unsynchronisedLyrics?: TypeOrTypeArray<TagFrames.UnsynchronisedLyrics>;
    // (undocumented)
    userDefinedText?: TypeOrTypeArray<TagFrames.UserDefinedText>;
    // (undocumented)
    userDefinedUrl?: TypeOrTypeArray<TagFrames.UserDefinedUrl>;
    // (undocumented)
    year?: TagFrames.Year;
}

// @public (undocumented)
export type TagConstants = typeof TagConstants;

// @public
export const TagConstants: {
    readonly TimeStampFormat: {
        readonly MPEG_FRAMES: 1;
        readonly MILLISECONDS: 2;
    };
    readonly EventTimingCodes: {
        readonly EventType: {
            readonly PADDING: 0;
            readonly END_OF_INITIAL_SILENCE: 1;
            readonly INTRO_START: 2;
            readonly MAINPART_START: 3;
            readonly OUTRO_START: 4;
            readonly OUTRO_END: 5;
            readonly VERSE_START: 6;
            readonly REFRAIN_START: 7;
            readonly INTERLUDE_START: 8;
            readonly THEME_START: 9;
            readonly VARIATION_START: 10;
            readonly KEY_CHANGE: 11;
            readonly TIME_CHANGE: 12;
            readonly MOMENTARY_UNWANTED_NOISE: 13;
            readonly SUSTAINED_NOISE: 14;
            readonly SUSTAINED_NOISE_END: 15;
            readonly INTRO_END: 16;
            readonly MAINPART_END: 17;
            readonly VERSE_END: 18;
            readonly REFRAIN_END: 19;
            readonly THEME_END: 20;
            readonly RESERVED_1: 21;
            readonly NOT_PREDEFINED_SYNC: 224;
            readonly RESERVED_2: 240;
            readonly AUDIO_END: 253;
            readonly AUDIO_FILE_ENDS: 254;
            readonly ONE_MORE_BYTE_FOLLOWS: 255;
        };
    };
    readonly SynchronisedLyrics: {
        readonly ContentType: {
            readonly OTHER: 0;
            readonly LYRICS: 1;
            readonly TEXT_TRANSCRIPTION: 2;
            readonly MOVEMENT_OR_PART_NAME: 3;
            readonly EVENTS: 4;
            readonly CHORD: 5;
            readonly TRIVIA_OR_POP_UP_INFORMATION: 6;
        };
    };
    readonly AttachedPicture: {
        readonly PictureType: {
            readonly OTHER: 0;
            readonly FILE_ICON: 1;
            readonly OTHER_FILE_ICON: 2;
            readonly FRONT_COVER: 3;
            readonly BACK_COVER: 4;
            readonly LEAFLET_PAGE: 5;
            readonly MEDIA: 6;
            readonly LEAD_ARTIST: 7;
            readonly ARTIST_OR_PERFORMER: 8;
            readonly CONDUCTOR: 9;
            readonly BAND_OR_ORCHESTRA: 10;
            readonly COMPOSER: 11;
            readonly LYRICIST_OR_TEXT_WRITER: 12;
            readonly RECORDING_LOCATION: 13;
            readonly DURING_RECORDING: 14;
            readonly DURING_PERFORMANCE: 15;
            readonly MOVIE_OR_VIDEO_SCREEN_CAPTURE: 16;
            readonly A_BRIGHT_COLOURED_FISH: 17;
            readonly ILLUSTRATION: 18;
            readonly BAND_OR_ARTIST_LOGOTYPE: 19;
            readonly PUBLISHER_OR_STUDIO_LOGOTYPE: 20;
        };
    };
    readonly CommercialFrame: {
        readonly ReceivedAs: {
            readonly OTHER: 0;
            readonly STANDARD_CD_ALBUM_WITH_OTHER_SONGS: 1;
            readonly COMPRESSED_AUDIO_ON_CD: 2;
            readonly FILE_OVER_THE_INTERNET: 3;
            readonly STREAM_OVER_THE_INTERNET: 4;
            readonly AS_NOTE_SHEETS: 5;
            readonly AS_NOTE_SHEETS_IN_A_BOOK_WITH_OTHER_SHEETS: 6;
            readonly MUSIC_ON_OTHER_MEDIA: 7;
            readonly NON_MUSICAL_MERCHANDISE: 8;
        };
    };
};

declare namespace TagFrames {
    export {
        Album,
        Bpm,
        Composer,
        Genre,
        Copyright,
        EncodingTime,
        RecordingDate,
        PlaylistDelay,
        OriginalReleaseTime,
        RecordingTime,
        ReleaseTime,
        TaggingTime,
        EncodedBy,
        TextWriter,
        FileType,
        InvolvedPeopleList,
        Time,
        ContentGroup,
        Title,
        Subtitle,
        InitialKey,
        Language,
        Length,
        MusicianCreditsList,
        MediaType,
        Mood,
        OriginalTitle,
        OriginalFilename,
        OriginalTextwriter,
        OriginalArtist,
        OriginalYear,
        FileOwner,
        Artist,
        PerformerInfo,
        Conductor,
        RemixArtist,
        PartOfSet,
        ProducedNotice,
        Publisher,
        TrackNumber,
        RecordingDates,
        InternetRadioName,
        InternetRadioOwner,
        AlbumSortOrder,
        PerformerSortOrder,
        TitleSortOrder,
        Size,
        ISRC,
        EncodingTechnology,
        SetSubtitle,
        Year,
        Comment,
        UnsynchronisedLyrics,
        SynchronisedLyrics,
        UserDefinedText,
        Image,
        Popularimeter,
        Private,
        UniqueFileIdentifier,
        Chapter,
        TableOfContents,
        CommercialUrl,
        CopyrightUrl,
        FileUrl,
        ArtistUrl,
        AudioSourceUrl,
        RadioStationUrl,
        PaymentUrl,
        PublisherUrl,
        UserDefinedUrl,
        EventTimingCodes,
        CommercialFrame
    }
}
export { TagFrames }

// @public
type TaggingTime = string;

// @public (undocumented)
export interface TagIdentifiers {
    // (undocumented)
    APIC?: TagAliases["image"];
    // (undocumented)
    CHAP?: TagAliases["chapter"];
    // (undocumented)
    COMM?: TagAliases["comment"];
    // (undocumented)
    COMR?: TagAliases["commercialFrame"];
    // (undocumented)
    CTOC?: TagAliases["tableOfContents"];
    // (undocumented)
    ETCO?: TagAliases["eventTimingCodes"];
    // (undocumented)
    POPM?: TagAliases["popularimeter"];
    // (undocumented)
    PRIV?: TagAliases["private"];
    // (undocumented)
    SYLT?: TagAliases["synchronisedLyrics"];
    // (undocumented)
    TALB?: TagAliases["album"];
    // (undocumented)
    TBPM?: TagAliases["bpm"];
    // (undocumented)
    TCOM?: TagAliases["composer"];
    // (undocumented)
    TCON?: TagAliases["genre"];
    // (undocumented)
    TCOP?: TagAliases["copyright"];
    // (undocumented)
    TDAT?: TagAliases["date"];
    // (undocumented)
    TDEN?: TagAliases["encodingTime"];
    // (undocumented)
    TDLY?: TagAliases["playlistDelay"];
    // (undocumented)
    TDOR?: TagAliases["originalReleaseTime"];
    // (undocumented)
    TDRC?: TagAliases["recordingTime"];
    // (undocumented)
    TDRL?: TagAliases["releaseTime"];
    // (undocumented)
    TDTG?: TagAliases["taggingTime"];
    // (undocumented)
    TENC?: TagAliases["encodedBy"];
    // (undocumented)
    TEXT?: TagAliases["textWriter"];
    // (undocumented)
    TFLT?: TagAliases["fileType"];
    // (undocumented)
    TIME?: TagAliases["time"];
    // (undocumented)
    TIPL?: TagAliases["involvedPeopleList"];
    // (undocumented)
    TIT1?: TagAliases["contentGroup"];
    // (undocumented)
    TIT2?: TagAliases["title"];
    // (undocumented)
    TIT3?: TagAliases["subtitle"];
    // (undocumented)
    TKEY?: TagAliases["initialKey"];
    // (undocumented)
    TLAN?: TagAliases["language"];
    // (undocumented)
    TLEN?: TagAliases["length"];
    // (undocumented)
    TMCL?: TagAliases["musicianCreditsList"];
    // (undocumented)
    TMED?: TagAliases["mediaType"];
    // (undocumented)
    TMOO?: TagAliases["mood"];
    // (undocumented)
    TOAL?: TagAliases["originalTitle"];
    // (undocumented)
    TOFN?: TagAliases["originalFilename"];
    // (undocumented)
    TOLY?: TagAliases["originalTextwriter"];
    // (undocumented)
    TOPE?: TagAliases["originalArtist"];
    // (undocumented)
    TORY?: TagAliases["originalYear"];
    // (undocumented)
    TOWN?: TagAliases["fileOwner"];
    // (undocumented)
    TPE1?: TagAliases["artist"];
    // (undocumented)
    TPE2?: TagAliases["performerInfo"];
    // (undocumented)
    TPE3?: TagAliases["conductor"];
    // (undocumented)
    TPE4?: TagAliases["remixArtist"];
    // (undocumented)
    TPOS?: TagAliases["partOfSet"];
    // (undocumented)
    TPRO?: TagAliases["producedNotice"];
    // (undocumented)
    TPUB?: TagAliases["publisher"];
    // (undocumented)
    TRCK?: TagAliases["trackNumber"];
    // (undocumented)
    TRDA?: TagAliases["recordingDates"];
    // (undocumented)
    TRSN?: TagAliases["internetRadioName"];
    // (undocumented)
    TRSO?: TagAliases["internetRadioOwner"];
    // (undocumented)
    TSIZ?: TagAliases["size"];
    // (undocumented)
    TSOA?: TagAliases["albumSortOrder"];
    // (undocumented)
    TSOP?: TagAliases["performerSortOrder"];
    // (undocumented)
    TSOT?: TagAliases["titleSortOrder"];
    // (undocumented)
    TSRC?: TagAliases["ISRC"];
    // (undocumented)
    TSSE?: TagAliases["encodingTechnology"];
    // (undocumented)
    TSST?: TagAliases["setSubtitle"];
    // (undocumented)
    TXXX?: TagAliases["userDefinedText"];
    // (undocumented)
    TYER?: TagAliases["year"];
    // (undocumented)
    UFID?: TagAliases["uniqueFileIdentifier"];
    // (undocumented)
    USLT?: TagAliases["unsynchronisedLyrics"];
    // (undocumented)
    WCOM?: TagAliases["commercialUrl"];
    // (undocumented)
    WCOP?: TagAliases["copyrightUrl"];
    // (undocumented)
    WOAF?: TagAliases["fileUrl"];
    // (undocumented)
    WOAR?: TagAliases["artistUrl"];
    // (undocumented)
    WOAS?: TagAliases["audioSourceUrl"];
    // (undocumented)
    WORS?: TagAliases["radioStationUrl"];
    // (undocumented)
    WPAY?: TagAliases["paymentUrl"];
    // (undocumented)
    WPUB?: TagAliases["publisherUrl"];
    // (undocumented)
    WXXX?: TagAliases["userDefinedUrl"];
}

// @public (undocumented)
export interface Tags extends TagAliases {
    // (undocumented)
    raw?: TagIdentifiers;
}

// @public
type TextWriter = string;

// @public
type Time = string;

// @public
type Title = string;

// @public
type TitleSortOrder = string;

// @public
type TrackNumber = string;

// @public
export type TypeOrTypeArray<T> = T | T[];

// @public
type UniqueFileIdentifier = {
    ownerIdentifier: string;
    identifier: Buffer;
};

// @public
interface UnsynchronisedLyrics {
    language: string;
    shortText?: string;
    text: string;
}

// @public
export function update(tags: WriteTags, buffer: Buffer, options?: Options): Buffer;

// @public
export function update(tags: WriteTags, filepath: string, options?: Options): true | Error;

// @public
export function update(tags: WriteTags, filebuffer: string | Buffer, callback: WriteCallback): void;

// @public
export function update(tags: WriteTags, filebuffer: string | Buffer, options: Options, callback: WriteCallback): void;

// @public (undocumented)
type UserDefinedText = {
    description: string;
    value: string;
};

// @public
type UserDefinedUrl = {
    description: string;
    url: string;
};

// @public
export function write(tags: WriteTags, buffer: Buffer): Buffer;

// @public
export function write(tags: WriteTags, filepath: string): true | Error;

// @public
export function write(tags: WriteTags, filebuffer: string | Buffer, callback: WriteCallback): void;

// @public
export type WriteCallback = WriteSuccessCallback & WriteErrorCallback;

// @public
export type WriteErrorCallback = (error: NodeJS.ErrnoException | Error, data: null) => void;

// @public
export type WriteSuccessCallback = (error: null, data: Buffer) => void;

// @public
export interface WriteTags extends TagAliases, TagIdentifiers {
}

// @public
type Year = string;

// Warnings were encountered during analysis:
//
// lib/src/types/TagFrames.d.ts:683:5 - (ae-forgotten-export) The symbol "Values" needs to be exported by the entry point index.d.ts

```
